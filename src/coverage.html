
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">d7024e/cli/cli.go (23.5%)</option>
				
				<option value="file1">d7024e/kademlia/bucket.go (100.0%)</option>
				
				<option value="file2">d7024e/kademlia/contact.go (100.0%)</option>
				
				<option value="file3">d7024e/kademlia/kademlia.go (35.2%)</option>
				
				<option value="file4">d7024e/kademlia/kademliaid.go (95.5%)</option>
				
				<option value="file5">d7024e/kademlia/network.go (58.1%)</option>
				
				<option value="file6">d7024e/kademlia/routingtable.go (100.0%)</option>
				
				<option value="file7">d7024e/kademlia/storage.go (82.4%)</option>
				
				<option value="file8">d7024e/utils/debug.go (100.0%)</option>
				
				<option value="file9">d7024e/utils/utils.go (73.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cli

import (
        "bufio"
        "d7024e/kademlia"
        "fmt"
        "os"
        "strings"
        "sync"
)

type CLI struct {
        kademlia *kademlia.Kademlia
        syncExit *sync.WaitGroup
}

// Create a new CLI instance.
func NewCLI(kademlia *kademlia.Kademlia, exit *sync.WaitGroup) CLI <span class="cov8" title="1">{
        return CLI{kademlia, exit}
}</span>

// Listen for user input and execute commands.
func (cli *CLI) Listen() <span class="cov0" title="0">{

        stdin := bufio.NewReader(os.Stdin)

        for </span><span class="cov0" title="0">{
                // Print commands
                fmt.Println("")
                fmt.Println("DEFINED COMMANDS:")
                fmt.Println("put [content]")
                fmt.Println("get [hash]")
                fmt.Println("forget [hash]")
                fmt.Println("exit")
                fmt.Println("")

                text, _ := stdin.ReadString('\n')
                text = strings.TrimRight(text, "\n")
                args := strings.SplitN(text, " ", 2)

                switch </span>{
                case text == "exit":<span class="cov0" title="0">
                        cli.exit()
                        return</span>
                case args[0] == "put" &amp;&amp; len(args) &gt; 1:<span class="cov0" title="0">
                        cli.put(args[1])</span>
                case args[0] == "get" &amp;&amp; len(args) &gt; 1:<span class="cov0" title="0">
                        cli.get(args[1])</span>
                case args[0] == "forget" &amp;&amp; len(args) &gt; 1:<span class="cov0" title="0">
                        cli.forget(args[1])</span>
                default:<span class="cov0" title="0">
                        fmt.Println("Invalid command.")</span>
                }
        }
}

// Handle put command by storing content on the network.
func (cli *CLI) put(content string) <span class="cov0" title="0">{
        hash := cli.kademlia.Store([]byte(content))
        fmt.Println("Stored content with hash", hash)
}</span>

// Handle get command by retrieving data from the network.
func (cli *CLI) get(hash string) <span class="cov8" title="1">{
        if len([]byte(hash)) != 40 </span><span class="cov8" title="1">{
                fmt.Printf("Expected hash length of 20 but got %d", len([]byte(hash)))
                return
        }</span>

        <span class="cov0" title="0">data := cli.kademlia.LookupData(hash)
        if data == nil </span><span class="cov0" title="0">{
                fmt.Println("Data not found")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Data:", string(data))
        }</span>
}

func (cli *CLI) forget(hash string) <span class="cov8" title="1">{
        if len([]byte(hash)) != 40 </span><span class="cov8" title="1">{
                fmt.Printf("Expected hash length of 20 but got %d", len([]byte(hash)))
                return
        }</span>

        <span class="cov8" title="1">cli.kademlia.Forget(hash)</span>
}

// Handle exit command by exiting the program.
func (cli *CLI) exit() <span class="cov0" title="0">{
        cli.syncExit.Done()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package kademlia

import (
        "container/list"
)

// bucket definition
// contains a List
type bucket struct {
        list *list.List
}

// newBucket returns a new instance of a bucket
func newBucket() *bucket <span class="cov8" title="1">{
        bucket := &amp;bucket{}
        bucket.list = list.New()
        return bucket
}</span>

// AddContact adds the Contact to the front of the bucket
// or moves it to the front of the bucket if it already existed
func (bucket *bucket) AddContact(contact Contact) <span class="cov8" title="1">{
        var element *list.Element
        for e := bucket.list.Front(); e != nil; e = e.Next() </span><span class="cov8" title="1">{
                nodeID := e.Value.(Contact).ID

                if (contact).ID.Equals(nodeID) </span><span class="cov8" title="1">{
                        element = e
                }</span>
        }

        <span class="cov8" title="1">if element == nil </span><span class="cov8" title="1">{
                if bucket.list.Len() &lt; bucketSize </span><span class="cov8" title="1">{
                        bucket.list.PushFront(contact)
                }</span>
        } else<span class="cov8" title="1"> {
                bucket.list.MoveToFront(element)
        }</span>
}

// GetContactAndCalcDistance returns an array of Contacts where
// the distance has already been calculated
func (bucket *bucket) GetContactAndCalcDistance(target *KademliaID) []Contact <span class="cov8" title="1">{
        var contacts []Contact

        for elt := bucket.list.Front(); elt != nil; elt = elt.Next() </span><span class="cov8" title="1">{
                contact := elt.Value.(Contact)
                contact.CalcDistance(target)
                contacts = append(contacts, contact)
        }</span>

        <span class="cov8" title="1">return contacts</span>
}

// Len return the size of the bucket
func (bucket *bucket) Len() int <span class="cov8" title="1">{
        return bucket.list.Len()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package kademlia

import (
        "errors"
        "fmt"
        "regexp"
        "sort"
)

// Contact definition
// stores the KademliaID, the ip address and the distance
type Contact struct {
        ID       *KademliaID
        Address  string
        distance *KademliaID
}

// NewContact returns a new instance of a Contact
func NewContact(id *KademliaID, address string) Contact <span class="cov8" title="1">{
        return Contact{id, address, nil}
}</span>

func NewContactFromString(str string) (Contact, error) <span class="cov8" title="1">{
        re := regexp.MustCompile(`contact\((.*?)\)`)

        // Find the first match of the pattern in the input string
        match := re.FindStringSubmatch(str)

        // Check if a match was found
        if len(match) &gt; 1 </span><span class="cov8" title="1">{
                // Split the elements string into a slice of elements
                elements := regexp.MustCompile(`,\s*`).Split(match[1], -1)
                return Contact{NewKademliaID(elements[0]), elements[1], NewKademliaID(elements[2])}, nil
        }</span>

        <span class="cov8" title="1">return NewContact(NewRandomKademliaID(), "0"), errors.New("NewContactFromString: failed to extract data from string")</span>
}

// CalcDistance calculates the distance to the target and
// fills the contacts distance field
func (contact *Contact) CalcDistance(target *KademliaID) <span class="cov8" title="1">{
        contact.distance = contact.ID.CalcDistance(target)
}</span>

// Less returns true if contact.distance &lt; otherContact.distance
func (contact *Contact) Less(otherContact *Contact) bool <span class="cov8" title="1">{
        return contact.distance.Less(otherContact.distance)
}</span>

// String returns a simple string representation of a Contact
func (contact *Contact) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(`contact(%s, %s, %s)`, contact.ID.String(), contact.Address, contact.distance.String())
}</span>

// ContactCandidates definition
// stores an array of Contacts
type ContactCandidates struct {
        contacts []Contact
}

// Append an array of Contacts to the ContactCandidates
func (candidates *ContactCandidates) Append(contacts []Contact) <span class="cov8" title="1">{
        candidates.contacts = append(candidates.contacts, contacts...)
}</span>

// GetContacts returns the first count number of Contacts
func (candidates *ContactCandidates) GetContacts(count int) []Contact <span class="cov8" title="1">{
        return candidates.contacts[:count]
}</span>

// Sort the Contacts in ContactCandidates
func (candidates *ContactCandidates) Sort() <span class="cov8" title="1">{
        sort.Sort(candidates)
}</span>

// Len returns the length of the ContactCandidates
func (candidates *ContactCandidates) Len() int <span class="cov8" title="1">{
        return len(candidates.contacts)
}</span>

// Swap the position of the Contacts at i and j
// WARNING does not check if either i or j is within range
func (candidates *ContactCandidates) Swap(i, j int) <span class="cov8" title="1">{
        candidates.contacts[i], candidates.contacts[j] = candidates.contacts[j], candidates.contacts[i]
}</span>

// Less returns true if the Contact at index i is smaller than
// the Contact at index j
func (candidates *ContactCandidates) Less(i, j int) bool <span class="cov8" title="1">{
        return candidates.contacts[i].Less(&amp;candidates.contacts[j])
}</span>

func (candidates *ContactCandidates) RemoveContact(contact *Contact) <span class="cov8" title="1">{
        // Find the index of the element to remove
        indexToRemove := -1
        for i, val := range candidates.contacts </span><span class="cov8" title="1">{
                if val == *contact </span><span class="cov8" title="1">{
                        indexToRemove = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if indexToRemove != -1 </span><span class="cov8" title="1">{
                candidates.contacts = append(candidates.contacts[:indexToRemove], candidates.contacts[indexToRemove+1:]...)
        }</span>
}

// Check if list contains target
func Contains(list []Contact, target Contact) bool <span class="cov8" title="1">{
        for _, item := range list </span><span class="cov8" title="1">{
                if item.ID.Equals(target.ID) </span><span class="cov8" title="1">{
                        return true // Element found in the list
                }</span>
        }
        <span class="cov8" title="1">return false</span> // Element not found in the list
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package kademlia

import (
        "d7024e/utils"
        "strings"
        "sync"
        "time"
)

var shortListMutex = &amp;sync.RWMutex{}
var respondedNodesMutex = &amp;sync.RWMutex{}

type Kademlia struct {
        network       *Network
        DataStore     map[string]string
        ClosestPeers  map[string][]Contact
        RefreshTicker *time.Ticker
}

// Create a new Kademlia instance.
func NewKademlia(network *Network) *Kademlia <span class="cov8" title="1">{
        return &amp;Kademlia{network, make(map[string]string), make(map[string][]Contact), time.NewTicker(network.refreshInterval)}
}</span>

// Join the network by pinging the contact node and then performing a node lookup.
func (kademlia *Kademlia) JoinNetwork(contact *Contact) <span class="cov0" title="0">{
        rpcID := NewRandomKademliaID()
        kademlia.network.SendPingMessage(contact, rpcID)
        &lt;-kademlia.network.CreateChannel(rpcID) // TODO: Listen with timeout

        utils.Log(1, "My routing table before node lookup:")
        for _, contact := range kademlia.network.rt.FindClosestContacts(kademlia.network.rt.me.ID, kademlia.network.k) </span><span class="cov0" title="0">{
                utils.Log(1, "%v, %v", contact.Address, contact.ID)
        }</span>

        <span class="cov0" title="0">kademlia.LookupContact(kademlia.network.rt.me.ID)

        utils.Log(1, "My routing table after node lookup:")
        for _, contact := range kademlia.network.rt.FindClosestContacts(kademlia.network.rt.me.ID, kademlia.network.k) </span><span class="cov0" title="0">{
                utils.Log(1, "%v, %v", contact.Address, contact.ID)
        }</span>
}

// Lookup a contact by performing a node lookup.
func (kademlia *Kademlia) LookupContact(target *KademliaID) <span class="cov8" title="1">{
        utils.Log(1, "Looking up contact %v", target)

        closestContacts, _ := kademlia.nodeLookup(target, FIND_NODE)

        utils.Log(1, "Closest contacts found to %v after node lookup:", target)
        for _, contact := range closestContacts </span><span class="cov0" title="0">{
                utils.Log(1, "%v, %v", contact.Address, contact.ID)
        }</span>
}

// Lookup data on the network by performing a node lookup. Returns the data.
func (kademlia *Kademlia) LookupData(hash string) []byte <span class="cov8" title="1">{
        utils.Log(1, "Looking up data for hash %v", hash)

        closestContactsWithoutValue, dataResult := kademlia.nodeLookup(NewKademliaID(hash), FIND_VALUE)

        if dataResult != nil &amp;&amp; len(closestContactsWithoutValue) &gt; 0 </span><span class="cov0" title="0">{
                utils.Log(1, "Closest contacts found to %v after data lookup that didn't return value:", hash)
                for _, contact := range closestContactsWithoutValue </span><span class="cov0" title="0">{
                        utils.Log(1, "%v, %v", contact.Address, contact.ID)
                }</span>

                // Store data on closest contact that didn't return the value (cache it)
                <span class="cov0" title="0">utils.Log(1, "Storing data %v on closest contact that didn't return the value", dataResult)
                utils.Log(1, "%v, %v", closestContactsWithoutValue[0].Address, closestContactsWithoutValue[0].ID)
                kademlia.network.SendStoreMessage(NewKademliaID(hash), dataResult, &amp;closestContactsWithoutValue[0], NewRandomKademliaID())</span>
        }

        <span class="cov8" title="1">return dataResult</span>
}

// Store data on the network by performing a node lookup and then storing the data on the closest contacts. Returns the hash of the data.
func (kademlia *Kademlia) Store(data []byte) string <span class="cov8" title="1">{
        utils.Log(1, "Storing data %v", data)

        hash := utils.Hash(data)
        key := NewKademliaID(hash)
        closestContacts, _ := kademlia.nodeLookup(key, STORE)

        // Store data on closest contacts
        utils.Log(1, "Closest contacts found to %v to store data at:", key)
        for _, contact := range closestContacts </span><span class="cov0" title="0">{
                kademlia.network.SendStoreMessage(key, data, &amp;contact, NewRandomKademliaID())
                utils.Log(1, "%v, %v", contact.Address, contact.ID)
        }</span>

        // Save closestContacts for this hash
        <span class="cov8" title="1">kademlia.ClosestPeers[key.String()] = closestContacts

        return hash</span>
}

// Start refresh routine for refreshing the closest peers to stored values
func (kademlia *Kademlia) StartRefreshRoutine() <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                for range kademlia.RefreshTicker.C </span><span class="cov0" title="0">{
                        kademlia.refreshClosestPeers()
                }</span>
        }()
}

// Refresh the closest peers to stored values.
func (kademlia *Kademlia) refreshClosestPeers() <span class="cov0" title="0">{
        for hash, contacts := range kademlia.ClosestPeers </span><span class="cov0" title="0">{
                for _, contact := range contacts </span><span class="cov0" title="0">{
                        go func(hash string, contact Contact) </span><span class="cov0" title="0">{
                                // Use a goroutine to prevent blocking the loop
                                // Implement SendRefreshMessage asynchronously
                                kademlia.network.SendRefreshMessage(NewKademliaID(hash), &amp;contact, NewRandomKademliaID())
                        }</span>(hash, contact)
                }
        }
}

func (kademlia *Kademlia) Forget(hash string) <span class="cov8" title="1">{
        key := NewKademliaID(hash)

        if _, ok := kademlia.ClosestPeers[key.String()]; !ok </span><span class="cov8" title="1">{
                utils.Log(1, "No closest peers found for hash %s", hash)
                return
        }</span>

        <span class="cov8" title="1">utils.Log(1, "Forgetting hash %s", hash)
        delete(kademlia.ClosestPeers, key.String())</span>
}

// Perform a node lookup on the network.
func (kademlia *Kademlia) nodeLookup(target *KademliaID, opType string) ([]Contact, []byte) <span class="cov8" title="1">{

        var data []byte
        var closerFound chan bool
        dataFound := make(chan []byte, kademlia.network.alpha)

        // Pick the alpha closest nodes to the target ID from the buckets and add to shortList.
        shortList := ContactCandidates{kademlia.network.rt.FindClosestContacts(target, kademlia.network.alpha)}

        utils.Log(1, "Shortlist at start of nodeLookup:")
        for _, contact := range shortList.contacts </span><span class="cov0" title="0">{
                utils.Log(1, "%v, %v", contact.Address, contact.ID)
        }</span>

        // Create a list of nodes that have already been contacted.
        <span class="cov8" title="1">contactedNodes := ContactCandidates{make([]Contact, 0)}

        // Create a list of nodes that have responded but not returned a value.
        respondedNodesWithoutValue := ContactCandidates{make([]Contact, 0)}

OUTER_LOOP:
        for </span><span class="cov8" title="1">{
                var iterativeSync sync.WaitGroup

                closerFound = make(chan bool, kademlia.network.alpha)

                // Filter out nodes that are already in contactedNodes
                alphaNodes := ContactCandidates{make([]Contact, 0)}
                allNodesContacted := true
                shortListMutex.RLock()
                for _, node := range shortList.contacts </span><span class="cov0" title="0">{
                        if !Contains(contactedNodes.contacts, node) &amp;&amp; !node.ID.Equals(kademlia.network.rt.me.ID) </span><span class="cov0" title="0">{
                                alphaNodes.Append([]Contact{node})
                                allNodesContacted = false
                        }</span>
                }
                <span class="cov8" title="1">shortListMutex.RUnlock()

                // Terminate when all nodes have been contacted.
                if allNodesContacted </span><span class="cov8" title="1">{
                        break</span>
                }

                // Limit the number of nodes in alphaNodes to alpha
                <span class="cov0" title="0">if alphaNodes.Len() &gt; kademlia.network.alpha </span><span class="cov0" title="0">{
                        // Sort inorder to prioritize messaging closer nodes
                        alphaNodes.Sort()
                        alphaNodes.contacts = alphaNodes.contacts[:kademlia.network.alpha]
                }</span>

                // Send RPCs to alphaNodes
                <span class="cov0" title="0">for _, node := range alphaNodes.contacts </span><span class="cov0" title="0">{
                        rpcID := NewRandomKademliaID()

                        if opType == FIND_NODE || opType == STORE </span><span class="cov0" title="0">{
                                kademlia.network.SendFindContactMessage(target, &amp;node, rpcID)
                        }</span> else<span class="cov0" title="0"> {
                                kademlia.network.SendFindDataMessage(target, &amp;node, rpcID)
                        }</span>

                        <span class="cov0" title="0">go kademlia.waitForResponse(&amp;iterativeSync, closerFound, dataFound, rpcID, &amp;shortList, &amp;respondedNodesWithoutValue, &amp;node)</span>
                }
                <span class="cov0" title="0">contactedNodes.Append(alphaNodes.contacts)

                // Loose parallelism
                time.Sleep(5 * time.Second)

                // Wait for a response from the alpha closest nodes in state.
                data = waitForFastest(&amp;iterativeSync, dataFound)
                if data != nil </span><span class="cov0" title="0">{
                        utils.Log(1, "Recieved FIND_VALUE_RESPONSE from node, Im done searching")
                        respondedNodesMutex.Lock()
                        respondedNodesWithoutValue.Sort()
                        shortListMutex.Lock()
                        shortList = ContactCandidates{respondedNodesWithoutValue.contacts}
                        shortListMutex.Unlock()
                        respondedNodesMutex.Unlock()
                        break OUTER_LOOP</span>
                }

                // If a closer node was found, set a flag that tells us to keep iterating
                <span class="cov0" title="0">closerFoundFlag := false
                for value := range closerFound </span><span class="cov0" title="0">{
                        if value </span><span class="cov0" title="0">{
                                closerFoundFlag = true
                                break</span>
                        }
                }

                // Otherwise, send a find node message to the k closest nodes in state that have not been contacted yet.
                <span class="cov0" title="0">if !closerFoundFlag </span><span class="cov0" title="0">{
                        var iterativeSync sync.WaitGroup
                        closerFound = make(chan bool, kademlia.network.k)
                        for _, node := range shortList.contacts </span><span class="cov0" title="0">{
                                rpcID := NewRandomKademliaID()

                                if !Contains(contactedNodes.contacts, node) </span><span class="cov0" title="0">{
                                        if opType == FIND_NODE || opType == STORE </span><span class="cov0" title="0">{
                                                kademlia.network.SendFindContactMessage(target, &amp;node, rpcID)
                                        }</span> else<span class="cov0" title="0"> {
                                                kademlia.network.SendFindDataMessage(target, &amp;node, rpcID)
                                        }</span>
                                        <span class="cov0" title="0">contactedNodes.Append([]Contact{node})
                                        go kademlia.waitForResponse(&amp;iterativeSync, closerFound, dataFound, rpcID, &amp;shortList, &amp;respondedNodesWithoutValue, &amp;node)</span>
                                }

                        }

                        // Wait for a response from the k closest nodes in state.
                        <span class="cov0" title="0">data = waitForFastest(&amp;iterativeSync, dataFound)
                        if data != nil </span><span class="cov0" title="0">{
                                utils.Log(1, "Recieved FIND_VALUE_RESPONSE from node, Im done searching")
                                respondedNodesMutex.Lock()
                                respondedNodesWithoutValue.Sort()
                                shortListMutex.Lock()
                                shortList = ContactCandidates{respondedNodesWithoutValue.contacts}
                                shortListMutex.Unlock()
                                respondedNodesMutex.Unlock()
                                break OUTER_LOOP</span>
                        }
                }
        }

        <span class="cov8" title="1">return shortList.contacts, data</span>
}

// Wait for a response from a node. If no response is received within 10 seconds, remove the node from the short list.
func (kademlia *Kademlia) waitForResponse(iterWait *sync.WaitGroup, status chan bool, data chan []byte, rpcID *KademliaID, shortList *ContactCandidates, respondedNodesWithoutValue *ContactCandidates, node *Contact) <span class="cov0" title="0">{

        iterWait.Add(1)
        // Wait for 10 sec if no response remove node from short list
        response, err := kademlia.network.ListenWithTimeout(rpcID, 10)
        if err != nil </span><span class="cov0" title="0">{
                shortListMutex.Lock()
                shortList.RemoveContact(node)
                shortListMutex.Unlock()

                status &lt;- false
                iterWait.Done()
                return
        }</span>

        // If response contains stored data, terminate and return it to the caller
        <span class="cov0" title="0">if response["type"] == FIND_VALUE_RESPONSE </span><span class="cov0" title="0">{
                utils.Log(1, "waitForResponse: got value from node: %s", node.Address)
                data &lt;- []byte(response["data"])
                iterWait.Done()
                return
        }</span>

        // Node responded and it wasn't a FIND_VALUE_RESPONSE, add it to respondedNodesWithoutValue
        <span class="cov0" title="0">respondedNodesMutex.Lock()
        if !Contains(respondedNodesWithoutValue.contacts, *node) &amp;&amp; response["type"] != FIND_VALUE_RESPONSE </span><span class="cov0" title="0">{
                respondedNodesWithoutValue.Append([]Contact{*node})
        }</span>
        <span class="cov0" title="0">respondedNodesMutex.Unlock()

        // Extract nodes from message
        responeContacts := []Contact{}
        strs := strings.Split(response["data"], "\n")
        conStrs := strs[:len(strs)-1] // remove last element (not a contact)

        for _, str := range conStrs </span><span class="cov0" title="0">{
                contact, err := NewContactFromString(str)
                if err != nil </span><span class="cov0" title="0">{
                        utils.LogError("nodeLookup: could not translate string to contact %s", err)
                        continue</span>
                }
                <span class="cov0" title="0">if contact.ID.Equals(kademlia.network.rt.me.ID) </span><span class="cov0" title="0">{
                        utils.Log(1, "nodeLookup: contact %s is me, discard", contact.Address)
                        continue</span>
                }
                <span class="cov0" title="0">responeContacts = append(responeContacts, contact)</span>
        }

        // Update shortList
        <span class="cov0" title="0">shortListMutex.Lock()
        nodesReplaced := updateShortList(shortList, responeContacts, kademlia.network.k)
        shortListMutex.Unlock()

        // If at least one node was replaced, send a new find node message to the alpha closest nodes in state.
        if nodesReplaced </span><span class="cov0" title="0">{
                utils.Log(1, "At least one node was replaced, looping again")

                status &lt;- false
                iterWait.Done()
                return
        }</span>

        <span class="cov0" title="0">status &lt;- true
        iterWait.Done()</span>
}

// Update the short list with new contacts.
func updateShortList(shortList *ContactCandidates, newContacts []Contact, k int) bool <span class="cov8" title="1">{
        // Filter out nodes that are already in shortList
        nodesReplaced := false
        for _, newNode := range newContacts </span><span class="cov8" title="1">{
                if Contains(shortList.contacts, newNode) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // If shortList contains less than k nodes, nodes are freely inserted into the state until it contains k nodes.
                <span class="cov8" title="1">if shortList.Len() &lt; k </span><span class="cov8" title="1">{
                        shortList.Append([]Contact{newNode})
                }</span> else<span class="cov8" title="1"> {
                        // shortList already contains k elements, replace the node furthest away with the new node if it is closer than the closest node in shortList
                        shortList.Sort()
                        if newNode.Less(&amp;shortList.contacts[0]) </span><span class="cov0" title="0">{
                                shortList.contacts[len(shortList.contacts)-1] = newNode
                                nodesReplaced = true
                        }</span>
                }
        }
        <span class="cov8" title="1">return nodesReplaced</span>
}

// Wait for the fastest response from a node.
func waitForFastest(wg *sync.WaitGroup, ch chan []byte) (data []byte) <span class="cov8" title="1">{
        done := make(chan struct{})
        var lock = &amp;sync.Mutex{}
        closed := false

        go func(group *sync.WaitGroup) </span><span class="cov8" title="1">{
                group.Wait()
                lock.Lock()
                if closed </span><span class="cov8" title="1">{
                        lock.Unlock()
                        return
                }</span>
                <span class="cov0" title="0">close(done)
                closed = true
                lock.Unlock()</span>
        }(wg)

        <span class="cov8" title="1">go func(channel chan []byte) </span><span class="cov8" title="1">{
                data = &lt;-channel
                lock.Lock()
                if closed </span><span class="cov0" title="0">{
                        lock.Unlock()
                        return
                }</span>
                <span class="cov8" title="1">close(done)
                closed = true
                lock.Unlock()</span>
        }(ch)

        <span class="cov8" title="1">&lt;-done
        return data</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package kademlia

import (
        "encoding/hex"
        "math/rand"
)

// the static number of bytes in a KademliaID
const IDLength = 20

// type definition of a KademliaID
type KademliaID [IDLength]byte

// NewKademliaID returns a new instance of a KademliaID based on the string input
func NewKademliaID(data string) *KademliaID <span class="cov8" title="1">{
        decoded, _ := hex.DecodeString(data)

        newKademliaID := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                newKademliaID[i] = decoded[i]
        }</span>

        <span class="cov8" title="1">return &amp;newKademliaID</span>
}

// NewRandomKademliaID returns a new instance of a random KademliaID,
// change this to a better version if you like
func NewRandomKademliaID() *KademliaID <span class="cov8" title="1">{
        newKademliaID := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                newKademliaID[i] = uint8(rand.Intn(256))
        }</span>
        <span class="cov8" title="1">return &amp;newKademliaID</span>
}

// Less returns true if kademliaID &lt; otherKademliaID (bitwise)
func (kademliaID KademliaID) Less(otherKademliaID *KademliaID) bool <span class="cov8" title="1">{
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                if kademliaID[i] != otherKademliaID[i] </span><span class="cov8" title="1">{
                        return kademliaID[i] &lt; otherKademliaID[i]
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Equals returns true if kademliaID == otherKademliaID (bitwise)
func (kademliaID KademliaID) Equals(otherKademliaID *KademliaID) bool <span class="cov8" title="1">{
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                if kademliaID[i] != otherKademliaID[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// CalcDistance returns a new instance of a KademliaID that is built
// through a bitwise XOR operation betweeen kademliaID and target
func (kademliaID KademliaID) CalcDistance(target *KademliaID) *KademliaID <span class="cov8" title="1">{
        result := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                result[i] = kademliaID[i] ^ target[i]
        }</span>
        <span class="cov8" title="1">return &amp;result</span>
}

// String returns a simple string representation of a KademliaID
func (kademliaID *KademliaID) String() string <span class="cov8" title="1">{
        return hex.EncodeToString(kademliaID[0:IDLength])
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package kademlia

import (
        "d7024e/protobuf"
        "d7024e/utils"
        "fmt"
        "net"
        "sync"
        "time"
)

// Mutex
var mComs sync.RWMutex
var mRoutingtable sync.RWMutex

// Defines the different message types sent over the network.
const (
        PING                string = "ping"
        PONG                string = "pong"
        FIND_NODE           string = "find_node"
        FIND_VALUE          string = "find_value"
        FIND_NODE_RESPONSE  string = "find_node_response"
        FIND_VALUE_RESPONSE string = "find_value_response"
        STORE               string = "store"
        REFRESH             string = "refresh"
)

type Network struct {
        rt      *RoutingTable
        storage *Storage
        coms    map[string]chan map[string]string

        k               int
        alpha           int
        ttl             time.Duration
        refreshInterval time.Duration
}

// Create a new Network instance.
func NewNetwork(rt *RoutingTable, k int, alpha int, ttl time.Duration, refreshInterval time.Duration) *Network <span class="cov8" title="1">{
        return &amp;Network{rt, NewStorage(ttl), make(map[string]chan map[string]string), k, alpha, ttl, refreshInterval}
}</span>

// Listens for incoming messages on a specified port.
func (network *Network) Listen(ip string, port int) <span class="cov0" title="0">{

        // Resolve the UDP address to bind to
        address := fmt.Sprintf("%s:%d", ip, port)
        udpAddr, err := net.ResolveUDPAddr("udp", address)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("Network.Listen net resolve %w", err)
        }</span>

        // Create a UDP connection to listen on the specified address
        <span class="cov0" title="0">conn, err := net.ListenUDP("udp", udpAddr)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("Network.Listen listen on udp %w", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        for </span><span class="cov0" title="0">{
                buffer := make([]byte, 4096) // Adjust buffer size as needed
                n, _, err := conn.ReadFromUDP(buffer)
                if err != nil </span><span class="cov0" title="0">{
                        utils.LogError("Network.Listen reading from udp %w", err)
                        continue</span>
                }

                // Handle incoming message in a separate goroutine
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        values, err := protobuf.DeserializeMessage(buffer[:n])
                        if err != nil </span><span class="cov0" title="0">{
                                utils.LogError("Listen failed to deserialize message %s", err)
                                return
                        }</span>
                        <span class="cov0" title="0">utils.Log(1, "Recieved %s message from %s", values["type"], values["sender_address"])
                        contact := NewContact(NewKademliaID(values["sender_id"]), values["sender_address"])

                        switch values["type"] </span>{
                        case PING:<span class="cov0" title="0">
                                network.SendPongMessage(&amp;contact, NewKademliaID(values["rpc_id"]))</span>

                        case FIND_NODE:<span class="cov0" title="0">
                                network.sendFindContactResponseMessage(values, &amp;contact)</span>

                        case FIND_VALUE:<span class="cov0" title="0">
                                // Similar to FIND_NODE, but return the value if found instead of contacts
                                data, exist := network.storage.FetchData(values["key"])
                                if !exist </span><span class="cov0" title="0">{
                                        network.sendFindContactResponseMessage(values, &amp;contact)
                                        break</span>
                                }

                                <span class="cov0" title="0">response := make(map[string]string)
                                response["rpc_id"] = values["rpc_id"]
                                response["sender_id"] = network.rt.me.ID.String()
                                response["sender_address"] = network.rt.me.Address
                                response["key"] = values["key"]
                                response["data"] = string(data)
                                response["type"] = FIND_VALUE_RESPONSE

                                data, err := protobuf.SerializeMessage(response)
                                if err != nil </span><span class="cov0" title="0">{
                                        utils.LogError("Listen FIND_VALUE could not serialize data %s", err)
                                        return
                                }</span>

                                <span class="cov0" title="0">utils.Log(1, "Sending %s message to %s", response["type"], values["sender_address"])
                                network.sendMessage(contact.Address, data)</span>

                        case STORE:<span class="cov0" title="0">
                                network.storage.StoreData(values["key"], []byte(values["data"]), network.ttl)</span>

                        case REFRESH:<span class="cov0" title="0">
                                // Refresh the TTL of the data object
                                wasRefreshed := network.storage.RefreshDataTTL(values["key"], network.ttl)

                                if wasRefreshed </span><span class="cov0" title="0">{
                                        utils.Log(3, "Data was refreshed with key %s", values["key"])
                                }</span>

                        default:<span class="cov0" title="0">
                                network.TransmitResponse(NewKademliaID(values["rpc_id"]), values)</span>
                        }

                        // Update routing table with sender
                        <span class="cov0" title="0">mRoutingtable.Lock()
                        network.rt.AddContact(contact)
                        mRoutingtable.Unlock()</span>
                }()
        }
}

// Sends a ping message to contact.
func (network *Network) SendPingMessage(contact *Contact, rpcID *KademliaID) <span class="cov8" title="1">{
        // Create a map to hold the values for the Ping message
        values := make(map[string]string)
        values["rpc_id"] = rpcID.String()
        values["sender_id"] = network.rt.me.ID.String()
        values["sender_address"] = network.rt.me.Address
        values["type"] = PING

        data, err := protobuf.SerializeMessage(values)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("SendPingPongMessage: could not build message (%s)", err)
                return
        }</span>

        <span class="cov8" title="1">utils.Log(1, "Sending %s message to %s", PING, contact.Address)
        network.sendMessage(contact.Address, data)</span>
}

// Sends a pong message to contact.
func (network *Network) SendPongMessage(contact *Contact, rpcID *KademliaID) <span class="cov8" title="1">{
        // Create a map to hold the values for the Ping message
        values := make(map[string]string)
        values["rpc_id"] = rpcID.String()
        values["sender_id"] = network.rt.me.ID.String()
        values["sender_address"] = network.rt.me.Address
        values["type"] = PONG

        data, err := protobuf.SerializeMessage(values)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("SendPingPongMessage: could not build message (%s)", err)
                return
        }</span>

        <span class="cov8" title="1">utils.Log(1, "Sending %s message to %s", PONG, contact.Address)
        network.sendMessage(contact.Address, data)</span>
}

// Sends a find node message to contact.
func (network *Network) SendFindContactMessage(id *KademliaID, contact *Contact, rpcID *KademliaID) <span class="cov8" title="1">{
        // Create a map to hold the values for the FindContact message
        values := make(map[string]string)
        values["rpc_id"] = rpcID.String()
        values["sender_id"] = network.rt.me.ID.String()
        values["sender_address"] = network.rt.me.Address
        values["key"] = id.String()
        values["type"] = FIND_NODE

        // Build message
        data, err := protobuf.SerializeMessage(values)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("SendFindContactMessage: could not build message (%s)", err)
                return
        }</span>

        // Send message
        <span class="cov8" title="1">utils.Log(1, "Sending %s message to %s", FIND_NODE, contact.Address)
        network.sendMessage(contact.Address, data)</span>
}

// Sends a find data message to contact.
func (network *Network) SendFindDataMessage(key *KademliaID, contact *Contact, rpcID *KademliaID) <span class="cov8" title="1">{
        // Create a map to hold the values for the FindData message
        values := make(map[string]string)
        values["rpc_id"] = rpcID.String()
        values["sender_id"] = network.rt.me.ID.String()
        values["sender_address"] = network.rt.me.Address
        values["key"] = key.String()
        values["type"] = FIND_VALUE

        // Build message
        data, err := protobuf.SerializeMessage(values)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("SendFindDataMessage: could not build message (%s)", err)
                return
        }</span>

        // Send message
        <span class="cov8" title="1">utils.Log(1, "Sending %s message to %s", FIND_VALUE, contact.Address)
        network.sendMessage(contact.Address, data)</span>
}

// Sends a store message to contact.
func (network *Network) SendStoreMessage(key *KademliaID, data []byte, contact *Contact, rpcID *KademliaID) <span class="cov8" title="1">{
        // Create a map to hold the values for the Store message
        values := make(map[string]string)
        values["rpc_id"] = rpcID.String()
        values["sender_id"] = network.rt.me.ID.String()
        values["sender_address"] = network.rt.me.Address
        values["key"] = key.String()
        values["data"] = string(data)
        values["type"] = STORE

        // Build message
        data, err := protobuf.SerializeMessage(values)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("SendStoreMessage: could not build message (%s)", err)
                return
        }</span>

        // Send message
        <span class="cov8" title="1">utils.Log(1, "Sending %s message to %s", STORE, contact.Address)
        network.sendMessage(contact.Address, data)</span>
}

// Sends a refresh message to contact.
func (network *Network) SendRefreshMessage(key *KademliaID, contact *Contact, rpcID *KademliaID) <span class="cov8" title="1">{
        // Create a map to hold the values for the Refresh message
        values := make(map[string]string)
        values["rpc_id"] = rpcID.String()
        values["sender_id"] = network.rt.me.ID.String()
        values["sender_address"] = network.rt.me.Address
        values["key"] = key.String()
        values["type"] = REFRESH

        // Build message
        data, err := protobuf.SerializeMessage(values)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("SendRefreshMessage: could not build message (%s)", err)
                return
        }</span>

        // Send message
        <span class="cov8" title="1">utils.Log(1, "Sending %s message to %s", REFRESH, contact.Address)
        network.sendMessage(contact.Address, data)</span>
}

// Sends a find node response message to contact.
func (network *Network) sendFindContactResponseMessage(values map[string]string, contact *Contact) <span class="cov8" title="1">{
        contacts := ""
        for _, node := range network.rt.FindClosestContacts(NewKademliaID(values["key"]), network.k) </span><span class="cov0" title="0">{
                contacts += node.String() + "\n"
        }</span>

        <span class="cov8" title="1">response := make(map[string]string)
        response["rpc_id"] = values["rpc_id"]
        response["sender_id"] = network.rt.me.ID.String()
        response["sender_address"] = network.rt.me.Address
        response["key"] = values["key"]
        response["data"] = contacts
        response["type"] = FIND_NODE_RESPONSE

        data, err := protobuf.SerializeMessage(response)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("Listen %s could not serialize data %s", values["type"], err)
                return
        }</span>

        <span class="cov8" title="1">utils.Log(1, "Sending %s message to %s", response["type"], values["sender_address"])
        network.sendMessage(contact.Address, data)</span>
}

// Sends a message to address.
func (network *Network) sendMessage(address string, data []byte) <span class="cov8" title="1">{
        // Create UDP connection
        conn, err := net.Dial("udp", address)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("SendMessage: ", err)
        }</span>

        // Write data to address
        <span class="cov8" title="1">_, err = conn.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("SendMessage: ", err)
        }</span>

        // Close connection
        <span class="cov8" title="1">conn.Close()</span>
}

// Listens on a specified channel for set amount of time before timing out.
func (network *Network) ListenWithTimeout(rpcID *KademliaID, sec int) (map[string]string, error) <span class="cov8" title="1">{
        network.CreateChannel(rpcID) // makes sure it exist

        select </span>{
        case res := &lt;-network.coms[rpcID.String()]:<span class="cov8" title="1">
                return res, nil</span>

        case &lt;-time.After(time.Duration(sec) * time.Second):<span class="cov8" title="1">
                return nil, fmt.Errorf("timeout occured")</span>

        }
}

// Sends data on a specified channel.
func (network *Network) TransmitResponse(rpcID *KademliaID, response map[string]string) <span class="cov0" title="0">{
        network.CreateChannel(rpcID) &lt;- response
}</span>

// Creates channel for rpc id if a channel does not already exist.
func (network *Network) CreateChannel(rpcID *KademliaID) chan map[string]string <span class="cov8" title="1">{
        mComs.Lock()
        _, exist := network.coms[rpcID.String()]
        if !exist </span><span class="cov8" title="1">{
                network.coms[rpcID.String()] = make(chan map[string]string, 50)
        }</span>
        <span class="cov8" title="1">mComs.Unlock()

        return network.coms[rpcID.String()]</span>
}

// Deletes channel for rpc id if it exists.
func (network *Network) RemoveChannel(rpcID *KademliaID) <span class="cov8" title="1">{
        mComs.Lock()
        _, exist := network.coms[rpcID.String()]
        if exist </span><span class="cov8" title="1">{
                delete(network.coms, rpcID.String())
        }</span>
        <span class="cov8" title="1">mComs.Unlock()</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package kademlia

const bucketSize = 20

// RoutingTable definition
// keeps a refrence contact of me and an array of buckets
type RoutingTable struct {
        me      Contact
        buckets [IDLength * 8]*bucket
}

// NewRoutingTable returns a new instance of a RoutingTable
func NewRoutingTable(me Contact) *RoutingTable <span class="cov8" title="1">{
        routingTable := &amp;RoutingTable{}
        for i := 0; i &lt; IDLength*8; i++ </span><span class="cov8" title="1">{
                routingTable.buckets[i] = newBucket()
        }</span>
        <span class="cov8" title="1">routingTable.me = me
        return routingTable</span>
}

// AddContact add a new contact to the correct Bucket
func (routingTable *RoutingTable) AddContact(contact Contact) <span class="cov8" title="1">{
        bucketIndex := routingTable.getBucketIndex(contact.ID)
        bucket := routingTable.buckets[bucketIndex]
        bucket.AddContact(contact)
}</span>

// FindClosestContacts finds the count closest Contacts to the target in the RoutingTable
func (routingTable *RoutingTable) FindClosestContacts(target *KademliaID, count int) []Contact <span class="cov8" title="1">{
        var candidates ContactCandidates
        bucketIndex := routingTable.getBucketIndex(target)
        bucket := routingTable.buckets[bucketIndex]

        candidates.Append(bucket.GetContactAndCalcDistance(target))

        for i := 1; (bucketIndex-i &gt;= 0 || bucketIndex+i &lt; IDLength*8) &amp;&amp; candidates.Len() &lt; count; i++ </span><span class="cov8" title="1">{
                if bucketIndex-i &gt;= 0 </span><span class="cov8" title="1">{
                        bucket = routingTable.buckets[bucketIndex-i]
                        candidates.Append(bucket.GetContactAndCalcDistance(target))
                }</span>
                <span class="cov8" title="1">if bucketIndex+i &lt; IDLength*8 </span><span class="cov8" title="1">{
                        bucket = routingTable.buckets[bucketIndex+i]
                        candidates.Append(bucket.GetContactAndCalcDistance(target))
                }</span>
        }

        <span class="cov8" title="1">candidates.Sort()

        if count &gt; candidates.Len() </span><span class="cov8" title="1">{
                count = candidates.Len()
        }</span>

        <span class="cov8" title="1">return candidates.GetContacts(count)</span>
}

// getBucketIndex get the correct Bucket index for the KademliaID
func (routingTable *RoutingTable) getBucketIndex(id *KademliaID) int <span class="cov8" title="1">{
        distance := id.CalcDistance(routingTable.me.ID)
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt; 8; j++ </span><span class="cov8" title="1">{
                        if (distance[i]&gt;&gt;uint8(7-j))&amp;0x1 != 0 </span><span class="cov8" title="1">{
                                return i*8 + j
                        }</span>
                }
        }

        <span class="cov8" title="1">return IDLength*8 - 1</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package kademlia

import (
        "d7024e/utils"
        "sync"
        "time"
)

type Storage struct {
        mu        sync.Mutex
        dataStore map[string]struct {
                Data []byte
                TTL  time.Time
        }
        DefaultTTL time.Duration
}

// Initializes the Storage struct with a default TTL value
func NewStorage(defaultTTL time.Duration) *Storage <span class="cov8" title="1">{
        storage := &amp;Storage{
                dataStore: make(map[string]struct {
                        Data []byte
                        TTL  time.Time
                }),
                DefaultTTL: defaultTTL,
        }

        // Start a goroutine to periodically clean up expired objects
        go storage.startCleanupTask()
        return storage
}</span>

// Stores data locally but does not overwrite any already defined key data pairs
func (storage *Storage) StoreData(key string, data []byte, ttl time.Duration) <span class="cov8" title="1">{
        storage.mu.Lock()
        defer storage.mu.Unlock()

        existingData, exist := storage.dataStore[key]
        if exist &amp;&amp; time.Now().Before(existingData.TTL) </span><span class="cov8" title="1">{
                utils.Log(3, "Tried to store data %s with key %s but that key already stores data %s", string(data), key, existingData.Data)
                return
        }</span>

        <span class="cov8" title="1">expirationTime := time.Now().Add(ttl)
        storage.dataStore[key] = struct {
                Data []byte
                TTL  time.Time
        }{Data: data, TTL: expirationTime}

        utils.Log(1, "Successfully stored data %s with key %s (TTL: %s)", string(data), key, expirationTime.String())</span>
}

// Tries to retrieve data and returns it together with the success of the fetch
func (storage *Storage) FetchData(key string) ([]byte, bool) <span class="cov8" title="1">{
        storage.mu.Lock()
        defer storage.mu.Unlock()

        existingData, exist := storage.dataStore[key]
        if exist &amp;&amp; time.Now().Before(existingData.TTL) </span><span class="cov8" title="1">{
                // Reset TTL since data object is requested
                storage.dataStore[key] = struct {
                        Data []byte
                        TTL  time.Time
                }{Data: existingData.Data, TTL: time.Now().Add(storage.DefaultTTL)}
                return existingData.Data, true
        }</span>

        // Delete the data object if TTL has expired
        <span class="cov8" title="1">delete(storage.dataStore, key)
        return nil, false</span>
}

// Refreshes the TTL for a data object if it exists and has not expired. Returns true if the TTL was refreshed.
func (storage *Storage) RefreshDataTTL(key string, ttl time.Duration) bool <span class="cov8" title="1">{
        storage.mu.Lock()
        defer storage.mu.Unlock()

        if storedData, exists := storage.dataStore[key]; exists &amp;&amp; time.Now().Before(storedData.TTL) </span><span class="cov8" title="1">{
                // Reset TTL for the data object
                storage.dataStore[key] = struct {
                        Data []byte
                        TTL  time.Time
                }{Data: storedData.Data, TTL: time.Now().Add(ttl)}
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Periodically checks and deletes expired objects from the data store
func (storage *Storage) startCleanupTask() <span class="cov8" title="1">{
        ticker := time.NewTicker(storage.DefaultTTL)
        for range ticker.C </span><span class="cov0" title="0">{
                storage.mu.Lock()
                for key, data := range storage.dataStore </span><span class="cov0" title="0">{
                        if time.Now().After(data.TTL) </span><span class="cov0" title="0">{
                                utils.Log(2, "Deleting expired data with key %s", key)
                                delete(storage.dataStore, key)
                        }</span>
                }
                <span class="cov0" title="0">storage.mu.Unlock()</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package utils

import (
        "fmt"
)

var severityThreshold int = 1
var errorPrefix string = "ERROR: "

// Logs message if severity is above the threshold (10 = ERROR)
func Log(severity int, format string, a ...any) <span class="cov8" title="1">{
        if severity &gt;= severityThreshold </span><span class="cov8" title="1">{
                fmt.Printf(format+"\n", a...)
        }</span>
}

// Logs error message.
func LogError(format string, a ...any) <span class="cov8" title="1">{
        if 10 &gt;= severityThreshold </span><span class="cov8" title="1">{
                fmt.Printf(errorPrefix+format+"\n", a...)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package utils

import (
        "crypto/sha1"
        "fmt"
        "net"
        "os"
)

// Returns the ip of this machine
func GetIP() (string, error) <span class="cov8" title="1">{
        // Get the hostname of the local machine
        hostname, err := os.Hostname()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("GetIP: failed to fetch hostname \n%w", err)
        }</span>

        // Resolve the hostname to get the IP addresses associated with it
        <span class="cov8" title="1">addrs, err := net.LookupIP(hostname)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("GetIP: failed to fetch ip addresses \n%w", err)
        }</span>

        // Resolve ip representation
        <span class="cov8" title="1">for _, addr := range addrs </span><span class="cov8" title="1">{
                if ipv4 := addr.To4(); ipv4 != nil </span><span class="cov0" title="0">{
                        return ipv4.String(), nil
                }</span> else<span class="cov8" title="1"> if ipv6 := addr.To16(); ipv6 != nil </span><span class="cov8" title="1">{
                        return ipv6.String(), nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("GetIP: no ip address could be linked to this machine")</span>
}

// Hashes a byte array using sha-1 and returns a 160-bit string (20 bytes)
func Hash(data []byte) string <span class="cov8" title="1">{
        hasher := sha1.New()
        hasher.Write(data)
        return fmt.Sprintf("%x", hasher.Sum(nil))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
